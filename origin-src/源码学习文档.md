# ElementUI Tree 组件源码学习

> 本文档基于 **架构 + 数据结构 + 经验** 三个维度，深入解析 ElementUI Tree 组件的实现原理。

---

## 一、架构设计

### 1.1 组件化架构

Tree 组件采用了**递归组件**的设计思想，分为两个核心组件：

#### **tree.vue** - 树容器组件
- **职责**：作为树的根容器，管理整体状态和交互
- **关键功能**：
  - 初始化 TreeStore 实例
  - 渲染根节点的子节点列表
  - 处理拖拽事件的全局监听和协调
  - 提供对外 API（如 `getCheckedNodes`、`setCheckedKeys` 等）
  - 键盘导航支持（上下左右、回车空格）

#### **tree-node.vue** - 树节点组件
- **职责**：渲染单个树节点，并递归渲染子节点
- **关键功能**：
  - 展示节点内容（图标、复选框、自定义内容）
  - 处理节点交互（点击、展开/收起、勾选）
  - 触发拖拽事件（dragstart、dragover、drop、dragend）
  - **递归渲染**：在自己的模板中引用自己来渲染子节点

```vue
<!-- tree-node.vue 核心结构 -->
<el-tree-node
  v-for="child in node.childNodes"
  :node="child"
  ...
></el-tree-node>
```

### 1.2 状态管理架构

Tree 组件没有使用 Vuex，而是通过 **TreeStore 类**实现了集中式状态管理：

```
┌─────────────────────────────────────────┐
│         tree.vue (视图层)                │
│  - props 配置                            │
│  - 事件分发                              │
└──────────────┬──────────────────────────┘
               │
               │ 创建和引用
               ▼
┌─────────────────────────────────────────┐
│      TreeStore (状态管理层)              │
│  - root: Node (根节点)                   │
│  - nodesMap: Object (节点映射表)         │
│  - currentNode: Node (当前节点)          │
│  - 提供增删改查节点的方法                │
└──────────────┬──────────────────────────┘
               │
               │ 管理节点实例
               ▼
┌─────────────────────────────────────────┐
│         Node (数据模型层)                │
│  - 节点属性（parent, children, level）  │
│  - 节点状态（checked, expanded, visible）│
│  - 节点操作方法                          │
└─────────────────────────────────────────┘
```

**状态管理特点**：
- **单一数据源**：所有节点状态由 TreeStore 统一管理
- **响应式联动**：节点状态变化会自动触发视图更新
- **解耦视图和数据**：组件只负责渲染，数据逻辑封装在 Model 层

### 1.3 分层架构

Tree 组件采用了清晰的**三层架构**：

| 层级 | 文件 | 职责 |
|-----|------|-----|
| **视图层** | `tree.vue`<br>`tree-node.vue` | 组件渲染、用户交互、事件处理 |
| **数据模型层** | `model/node.js`<br>`model/tree-store.js` | 树的数据结构、状态管理、业务逻辑 |
| **工具层** | `model/util.js` | 通用工具函数（节点标记、查找等） |

**分层的优势**：
- 职责清晰，易于维护和测试
- 数据模型可复用（如 Node 类可独立使用）
- 业务逻辑与 Vue 框架解耦

---

## 二、数据结构设计

### 2.1 核心数据结构

#### **Node 类** - 树节点模型

```javascript
class Node {
  constructor(options) {
    this.id = nodeIdSeed++;           // 唯一 ID
    this.parent = null;                // 父节点引用
    this.childNodes = [];              // 子节点数组
    this.level = 0;                    // 节点层级
    this.data = null;                  // 原始数据
    
    // 状态属性
    this.checked = false;              // 选中状态
    this.indeterminate = false;        // 半选状态
    this.expanded = false;             // 展开状态
    this.visible = true;               // 可见性
    this.isCurrent = false;            // 是否为当前节点
    this.isLeaf = false;               // 是否为叶子节点
    
    // 懒加载相关
    this.loaded = false;               // 是否已加载
    this.loading = false;              // 是否加载中
  }
}
```

**设计亮点**：
- **双向引用**：通过 `parent` 和 `childNodes` 实现父子双向关联
- **状态自包含**：每个节点封装自己的状态，便于管理
- **扩展性**：通过 getter 实现 `label`、`key`、`disabled` 等动态属性

#### **TreeStore 类** - 全局状态管理

```javascript
class TreeStore {
  constructor(options) {
    this.root = new Node({ data, store: this });  // 根节点
    this.nodesMap = {};                            // 节点映射表
    this.currentNode = null;                       // 当前选中节点
    this.key = options.key;                        // 节点唯一标识字段
    // ... 其他配置
  }
}
```

**nodesMap 的作用**：
```javascript
// O(1) 时间复杂度快速查找节点
nodesMap = {
  '1': Node实例1,
  '2': Node实例2,
  // ...
}
```

### 2.2 数据结构关系图

```
TreeStore
  ├── root (Node)
  │     ├── data: [] (原始数据数组)
  │     └── childNodes: [Node, Node, Node]
  │           ├── Node
  │           │   ├── parent: Node (指向父节点)
  │           │   ├── childNodes: [Node, Node]
  │           │   └── data: { id, label, children }
  │           └── Node
  │                 ├── parent: Node
  │                 └── childNodes: []
  └── nodesMap: {
        '1': Node,
        '2': Node
      }
```

### 2.3 数据流转过程

#### **初始化流程**：
```javascript
// 1. 用户传入原始数据
data = [
  { id: 1, label: '节点1', children: [...] },
  { id: 2, label: '节点2', children: [...] }
]

// 2. tree.vue 创建 TreeStore
this.store = new TreeStore({ data, ... });

// 3. TreeStore 创建 root 节点
this.root = new Node({ data, store: this });

// 4. Node 构造函数中调用 setData
this.setData(data);

// 5. setData 遍历 children，递归创建子节点
children.forEach(child => {
  this.insertChild({ data: child });
});
```

#### **节点选中流程**（级联选择）：
```javascript
// 用户勾选节点
node.setChecked(true, true);

// 向下级联：勾选所有子节点
childNodes.forEach(child => {
  child.setChecked(true, deep, true, passValue);
});

// 向上级联：重新计算父节点状态
reInitChecked(parent);
// 如果所有子节点都选中 → 父节点选中
// 如果部分子节点选中 → 父节点半选
// 如果所有子节点都未选中 → 父节点未选中
```

---

## 三、核心经验总结

### 3.1 面向对象编程实践

#### **封装性**：Node 类和 TreeStore 类分别封装节点和树的逻辑

```javascript
// ✅ 好处：逻辑内聚，对外只暴露必要的方法
class Node {
  expand() { ... }           // 展开节点
  collapse() { ... }         // 收起节点
  setChecked() { ... }       // 设置选中状态
  insertChild() { ... }      // 插入子节点
}
```

#### **继承性**：虽然代码中没有显式继承，但通过原型链实现了方法共享

#### **多态性**：通过配置项实现不同行为
```javascript
// 通过 props 配置，可以自定义数据字段
props: {
  label: 'name',      // 标签字段
  children: 'items',  // 子节点字段
  disabled: 'isDisabled'
}
```

#### **关联性**：Node 和 TreeStore 互相引用
```javascript
// Node 持有 TreeStore 引用
this.store = options.store;

// TreeStore 管理所有 Node 实例
this.nodesMap[node.key] = node;
```

### 3.2 原生拖拽 API 的使用

Tree 组件实现了完整的拖拽功能，使用了 HTML5 Drag and Drop API：

#### **拖拽事件流**：
```
拖动开始 (dragstart)
    ↓
经过目标 (dragover) ← 不断触发，计算放置位置
    ↓
放下 (drop)
    ↓
拖动结束 (dragend)
```

#### **核心实现**：

**1. dragstart - 拖动开始**
```javascript
// tree-node.vue
handleDragStart(event) {
  this.tree.$emit('tree-node-drag-start', event, this);
}

// tree.vue
this.$on('tree-node-drag-start', (event, treeNode) => {
  event.dataTransfer.effectAllowed = 'move';
  event.dataTransfer.setData('text/plain', '');  // Firefox 兼容
  dragState.draggingNode = treeNode;             // 记录拖动节点
});
```

**2. dragover - 计算放置位置**
```javascript
this.$on('tree-node-drag-over', (event, treeNode) => {
  // 计算鼠标位置，判断是 before/after/inner
  const distance = event.clientY - targetPosition.top;
  if (distance < targetPosition.height * 0.25) {
    dropType = 'before';  // 放在节点前面
  } else if (distance > targetPosition.height * 0.75) {
    dropType = 'after';   // 放在节点后面
  } else {
    dropType = 'inner';   // 放在节点内部（成为子节点）
  }
  
  // 更新放置指示器位置
  dropIndicator.style.top = indicatorTop + 'px';
});
```

**3. dragend - 完成拖拽**
```javascript
this.$on('tree-node-drag-end', (event) => {
  const { draggingNode, dropNode, dropType } = dragState;
  
  // 移除被拖动节点
  draggingNode.node.remove();
  
  // 根据 dropType 插入到目标位置
  if (dropType === 'before') {
    dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
  } else if (dropType === 'after') {
    dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
  } else if (dropType === 'inner') {
    dropNode.node.insertChild(draggingNodeCopy);
  }
  
  // 重新注册节点
  this.store.registerNode(draggingNodeCopy);
});
```

#### **拖拽限制**：
```javascript
// 防止非法拖拽
if (dropNode.node.contains(draggingNode.node)) {
  dropInner = false;  // 不能拖到自己的子节点内
}
if (draggingNode.node === dropNode.node) {
  // 不能拖到自己身上
  dropPrev = dropInner = dropNext = false;
}
```

### 3.3 递归组件设计

**tree-node.vue 自引用**：
```vue
<template>
  <div class="el-tree-node">
    <!-- 节点内容 -->
    <div class="el-tree-node__content">...</div>
    
    <!-- 递归渲染子节点 -->
    <el-tree-node
      v-for="child in node.childNodes"
      :node="child"
      :key="getNodeKey(child)"
    ></el-tree-node>
  </div>
</template>
```

**优势**：
- 无需关心树的深度，自动处理任意层级
- 代码简洁，逻辑复用

### 3.4 懒加载机制

```javascript
// Node.js - 按需加载子节点
expand(callback) {
  if (this.shouldLoadData()) {
    this.loadData((data) => {
      // 数据加载完成后展开
      this.expanded = true;
    });
  } else {
    this.expanded = true;
  }
}

loadData(callback) {
  this.loading = true;
  this.store.load(this, (children) => {
    this.doCreateChildren(children);
    this.loaded = true;
    this.loading = false;
    callback && callback();
  });
}
```

**应用场景**：大数据量树形结构，按需加载提升性能

### 3.5 复选框级联逻辑

**关键算法** - `getChildState` 和 `reInitChecked`：

```javascript
// 计算子节点的选中状态
const getChildState = node => {
  let all = true;   // 是否全选
  let none = true;  // 是否全不选
  
  node.forEach(n => {
    if (n.checked !== true) all = false;
    if (n.checked !== false) none = false;
  });
  
  return { all, none, half: !all && !none };
};

// 向上递归更新父节点状态
const reInitChecked = function(node) {
  const { all, none, half } = getChildState(node.childNodes);
  
  if (all) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;  // 半选状态
  } else {
    node.checked = false;
    node.indeterminate = false;
  }
  
  // 递归更新父节点
  if (node.parent && node.parent.level > 0) {
    reInitChecked(node.parent);
  }
};
```

### 3.6 性能优化技巧

#### **1. 节点映射表 (nodesMap)**
```javascript
// 避免遍历整棵树查找节点
getNode(data) {
  const key = getNodeKey(this.key, data);
  return this.nodesMap[key];  // O(1) 复杂度
}
```

#### **2. 延迟渲染 (renderAfterExpand)**
```vue
<!-- 只有展开后才渲染子节点 -->
<div v-if="!renderAfterExpand || childNodeRendered">
  <el-tree-node v-for="child in node.childNodes" ...></el-tree-node>
</div>
```

#### **3. 节点标记 (NODE_KEY)**
```javascript
// 为原始数据对象添加不可枚举的节点 ID
Object.defineProperty(data, NODE_KEY, {
  value: node.id,
  enumerable: false,   // 不可遍历
  configurable: false, // 不可配置
  writable: false      // 不可写
});
```

### 3.7 键盘导航支持

```javascript
// tree.vue - 键盘事件处理
handleKeydown(ev) {
  const keyCode = ev.keyCode;
  if ([38, 40].indexOf(keyCode) > -1) {  // 上下键
    // 移动焦点到上/下一个节点
    this.treeItemArray[nextIndex].focus();
  }
  if ([37, 39].indexOf(keyCode) > -1) {  // 左右键
    currentItem.click();  // 展开/收起节点
  }
  if ([13, 32].indexOf(keyCode) > -1) {  // Enter/Space
    hasInput.click();     // 切换复选框
  }
}
```

**无障碍支持**：
- 添加 `role="tree"` 和 `role="treeitem"` 属性
- 使用 `aria-expanded`、`aria-checked` 等属性

---

## 四、架构设计模式总结

### 4.1 设计模式应用

| 设计模式 | 应用场景 |
|---------|---------|
| **单例模式** | 每个 Tree 组件只有一个 TreeStore 实例 |
| **工厂模式** | TreeStore 通过 `new Node()` 统一创建节点 |
| **观察者模式** | 节点状态变化通过 `$emit` 通知组件 |
| **组合模式** | 树形结构，节点统一接口，递归处理 |
| **策略模式** | 通过 `allowDrag`、`allowDrop` 自定义拖拽策略 |

### 4.2 核心技术点

1. **递归组件** - 实现任意层级树形结构
2. **面向对象** - Node 和 TreeStore 类的职责划分
3. **状态集中管理** - TreeStore 管理所有节点状态
4. **原生拖拽 API** - HTML5 Drag and Drop
5. **性能优化** - nodesMap、延迟渲染、节点标记
6. **无障碍支持** - ARIA 属性、键盘导航

### 4.3 值得借鉴的实践

- ✅ **数据与视图分离**：Model 层可独立于 Vue 使用
- ✅ **配置化设计**：通过 props 支持多种场景
- ✅ **边界处理**：拖拽限制、懒加载、空树提示
- ✅ **扩展性**：支持自定义渲染（renderContent、scoped slot）
- ✅ **向上兼容**：通过配置保持 API 向后兼容

---

## 五、学习要点总结

### 核心收获

1. **组件化思维**：大组件拆分成小组件，职责清晰
2. **数据结构**：树形结构的 Node 类设计和双向引用
3. **状态管理**：不依赖 Vuex 也能做好状态管理
4. **递归思想**：递归组件、递归算法的应用
5. **原生 API**：HTML5 拖拽 API 的完整实现
6. **性能优化**：映射表、延迟渲染等实用技巧

### 关键代码位置

| 功能 | 文件 | 关键行数 |
|-----|------|---------|
| 递归组件渲染 | `tree-node.vue` | 60-69 |
| TreeStore 初始化 | `tree.vue` | 325-339 |
| 拖拽事件处理 | `tree.vue` | 344-483 |
| Node 类构造函数 | `model/node.js` | 66-136 |
| 复选框级联逻辑 | `model/node.js` | 356-407 |
| 节点映射注册 | `model/tree-store.js` | 136-142 |

---

> **总结**：ElementUI Tree 组件通过清晰的架构分层、合理的数据结构设计和面向对象编程，实现了功能强大且易于维护的树形控件。其代码质量、设计思想和实现细节都值得深入学习和借鉴。