# Tree 组件复刻步骤

> 本文档基于 **架构 + 数据结构 + 经验** 公式，提供渐进式的 Tree 组件复刻实现路径。

---

## 复刻原则

1. **循序渐进**：从简单到复杂，每一步都有可运行的成果
2. **架构优先**：先搭建分层架构，再填充功能细节
3. **数据驱动**：先实现数据模型，再实现视图渲染
4. **测试验证**：每完成一步，必须通过功能验证

---

## Step 1: 搭建项目基础架构（数据结构 - 目录结构）

### 📋 本步目标
创建 Tree 组件的目录结构和文件骨架，建立清晰的分层架构。

### ✅ 要达到的效果
- 完成三层架构的目录划分（视图层、数据模型层、工具层）
- 所有文件创建完成，但只包含基本骨架代码
- 组件可以在页面中引入，但暂时只显示一个空的 div

### 🎯 该做什么
1. **创建目录结构**：
   ```
   tree/
   ├── index.js                    # 入口文件
   ├── src/
   │   ├── tree.vue               # 树容器组件
   │   ├── tree-node.vue          # 树节点组件
   │   └── model/
   │       ├── node.js            # Node 类
   │       ├── tree-store.js      # TreeStore 类
   │       └── util.js            # 工具函数
   ```

2. **创建 index.js**：
   ```javascript
   import Tree from './src/tree.vue';
   
   Tree.install = function(Vue) {
     Vue.component(Tree.name, Tree);
   };
   
   export default Tree;
   ```

3. **创建 tree.vue 骨架**：
   ```vue
   <template>
     <div class="el-tree" role="tree">
       <!-- 待实现 -->
     </div>
   </template>
   
   <script>
   export default {
     name: 'ElTree',
     props: {
       data: Array
     },
     data() {
       return {
         store: null,
         root: null
       };
     }
   };
   </script>
   ```

4. **创建 tree-node.vue 骨架**：
   ```vue
   <template>
     <div class="el-tree-node" role="treeitem">
       <!-- 待实现 -->
     </div>
   </template>
   
   <script>
   export default {
     name: 'ElTreeNode',
     props: {
       node: Object
     }
   };
   </script>
   ```

5. **创建空的 model 文件**：
   ```javascript
   // model/node.js
   export default class Node {}
   
   // model/tree-store.js
   export default class TreeStore {}
   
   // model/util.js
   export const getNodeKey = function() {};
   ```

### ❌ 不该做什么
- ❌ 不要实现任何业务逻辑
- ❌ 不要添加样式代码
- ❌ 不要处理数据转换
- ❌ 不要考虑性能优化

### 🌿 分支命名
```bash
git checkout -b feature/tree-step1-architecture
```

### ✔️ 验收标准
- [ ] 目录结构完整，符合三层架构
- [ ] 所有文件已创建，无语法错误
- [ ] 组件可以在测试页面中引入并渲染（显示空 div）
- [ ] 代码通过 ESLint 检查

---

## Step 2: 实现 Node 数据模型（数据结构 - Node 类）

### 📋 本步目标
实现 Node 类，构建树节点的数据模型，建立父子双向引用关系。

### ✅ 要达到的效果
- Node 类可以创建节点实例
- 节点具备基本属性（id, level, data, parent, childNodes）
- 可以通过 setData 方法递归创建子节点
- 节点具备基本操作方法（expand, collapse, insertChild, remove）

### 🎯 该做什么
1. **实现 Node 类构造函数**：
   ```javascript
   let nodeIdSeed = 0;
   
   export default class Node {
     constructor(options) {
       // 基本属性
       this.id = nodeIdSeed++;
       this.text = null;
       this.data = null;
       this.parent = null;
       this.level = 0;
       this.childNodes = [];
       
       // 状态属性（先声明，暂不实现逻辑）
       this.expanded = false;
       this.visible = true;
       this.checked = false;
       this.indeterminate = false;
       this.isCurrent = false;
       this.isLeaf = false;
       
       // 懒加载相关
       this.loaded = false;
       this.loading = false;
       
       // 复制 options 属性
       for (let name in options) {
         if (options.hasOwnProperty(name)) {
           this[name] = options[name];
         }
       }
       
       // 计算层级
       if (this.parent) {
         this.level = this.parent.level + 1;
       }
       
       // 注册到 store
       const store = this.store;
       if (!store) {
         throw new Error('[Node]store is required!');
       }
       store.registerNode(this);
       
       // 设置数据（如果不是懒加载）
       if (store.lazy !== true && this.data) {
         this.setData(this.data);
       }
       
       this.updateLeafState();
     }
   }
   ```

2. **实现 setData 方法**（递归创建子节点）：
   ```javascript
   setData(data) {
     this.data = data;
     this.childNodes = [];
     
     let children;
     if (this.level === 0 && this.data instanceof Array) {
       children = this.data;  // 根节点的 data 就是数组
     } else {
       // 从配置中获取 children 字段
       const childrenKey = this.store.props?.children || 'children';
       children = data[childrenKey] || [];
     }
     
     // 递归创建子节点
     for (let i = 0, j = children.length; i < j; i++) {
       this.insertChild({ data: children[i] });
     }
   }
   ```

3. **实现节点操作方法**：
   ```javascript
   // 插入子节点
   insertChild(child, index) {
     if (!child) throw new Error('insertChild error: child is required.');
     
     if (!(child instanceof Node)) {
       Object.assign(child, {
         parent: this,
         store: this.store
       });
       child = new Node(child);
     }
     
     child.level = this.level + 1;
     
     if (typeof index === 'undefined' || index < 0) {
       this.childNodes.push(child);
     } else {
       this.childNodes.splice(index, 0, child);
     }
     
     this.updateLeafState();
   }
   
   // 移除节点
   remove() {
     const parent = this.parent;
     if (parent) {
       parent.removeChild(this);
     }
   }
   
   removeChild(child) {
     const index = this.childNodes.indexOf(child);
     if (index > -1) {
       this.store && this.store.deregisterNode(child);
       child.parent = null;
       this.childNodes.splice(index, 1);
     }
     this.updateLeafState();
   }
   
   // 展开收起（暂时只修改状态）
   expand() {
     this.expanded = true;
   }
   
   collapse() {
     this.expanded = false;
   }
   
   // 更新叶子节点状态
   updateLeafState() {
     this.isLeaf = this.childNodes.length === 0;
   }
   ```

4. **实现动态属性 getter**：
   ```javascript
   get label() {
     const labelKey = this.store.props?.label || 'label';
     return this.data?.[labelKey];
   }
   
   get key() {
     const nodeKey = this.store.key;
     if (this.data) return this.data[nodeKey];
     return null;
   }
   ```

### ❌ 不该做什么
- ❌ 不要实现复选框逻辑（setChecked）
- ❌ 不要实现懒加载逻辑（loadData）
- ❌ 不要实现节点过滤功能
- ❌ 不要处理事件触发

### 🌿 分支命名
```bash
git checkout -b feature/tree-step2-node-model
```

### ✔️ 验收标准
- [ ] 可以创建 Node 实例，包含完整属性
- [ ] setData 可以递归创建子节点树
- [ ] 父子节点正确建立双向引用（parent 和 childNodes）
- [ ] 节点层级（level）计算正确
- [ ] insertChild 和 remove 方法工作正常
- [ ] 通过单元测试验证基本功能

---

## Step 3: 实现 TreeStore 状态管理（数据结构 - TreeStore 类）

### 📋 本步目标
实现 TreeStore 类，作为全局状态管理中心，管理所有节点实例。

### ✅ 要达到的效果
- TreeStore 可以接收配置参数并初始化
- 创建根节点（root），并递归创建整棵树
- 维护 nodesMap 映射表，实现快速节点查找
- 提供节点的增删改查方法

### 🎯 该做什么
1. **实现 TreeStore 构造函数**：
   ```javascript
   import Node from './node';
   import { getNodeKey } from './util';
   
   export default class TreeStore {
     constructor(options) {
       this.currentNode = null;
       this.currentNodeKey = null;
       
       // 复制配置
       for (let option in options) {
         if (options.hasOwnProperty(option)) {
           this[option] = options[option];
         }
       }
       
       // 节点映射表
       this.nodesMap = {};
       
       // 创建根节点
       this.root = new Node({
         data: this.data,
         store: this
       });
     }
   }
   ```

2. **实现节点注册和注销**：
   ```javascript
   registerNode(node) {
     const key = this.key;
     if (!key || !node || !node.data) return;
     
     const nodeKey = node.key;
     if (nodeKey !== undefined) {
       this.nodesMap[node.key] = node;
     }
   }
   
   deregisterNode(node) {
     const key = this.key;
     if (!key || !node || !node.data) return;
     
     // 递归注销子节点
     node.childNodes.forEach(child => {
       this.deregisterNode(child);
     });
     
     delete this.nodesMap[node.key];
   }
   ```

3. **实现节点查找**：
   ```javascript
   getNode(data) {
     if (data instanceof Node) return data;
     const key = typeof data !== 'object' ? data : getNodeKey(this.key, data);
     return this.nodesMap[key] || null;
   }
   ```

4. **实现节点增删操作**：
   ```javascript
   append(data, parentData) {
     const parentNode = parentData ? this.getNode(parentData) : this.root;
     if (parentNode) {
       parentNode.insertChild({ data });
     }
   }
   
   insertBefore(data, refData) {
     const refNode = this.getNode(refData);
     refNode.parent.insertBefore({ data }, refNode);
   }
   
   insertAfter(data, refData) {
     const refNode = this.getNode(refData);
     refNode.parent.insertAfter({ data }, refNode);
   }
   
   remove(data) {
     const node = this.getNode(data);
     if (node && node.parent) {
       if (node === this.currentNode) {
         this.currentNode = null;
       }
       node.parent.removeChild(node);
     }
   }
   ```

5. **实现数据更新**：
   ```javascript
   setData(newVal) {
     const instanceChanged = newVal !== this.root.data;
     if (instanceChanged) {
       this.root.setData(newVal);
     } else {
       this.root.updateChildren();
     }
   }
   ```

6. **实现当前节点管理**：
   ```javascript
   setCurrentNode(currentNode) {
     const prevCurrentNode = this.currentNode;
     if (prevCurrentNode) {
       prevCurrentNode.isCurrent = false;
     }
     this.currentNode = currentNode;
     this.currentNode.isCurrent = true;
   }
   
   getCurrentNode() {
     return this.currentNode;
   }
   
   setCurrentNodeKey(key) {
     if (key === null || key === undefined) {
       this.currentNode && (this.currentNode.isCurrent = false);
       this.currentNode = null;
       return;
     }
     const node = this.getNode(key);
     if (node) {
       this.setCurrentNode(node);
     }
   }
   ```

### ❌ 不该做什么
- ❌ 不要实现复选框相关方法（getCheckedNodes、setCheckedKeys）
- ❌ 不要实现过滤功能（filter）
- ❌ 不要实现懒加载逻辑
- ❌ 不要实现默认展开/选中的初始化

### 🌿 分支命名
```bash
git checkout -b feature/tree-step3-tree-store
```

### ✔️ 验收标准
- [ ] TreeStore 可以接收配置并正确初始化
- [ ] root 节点创建成功，树结构正确
- [ ] nodesMap 正确维护所有节点引用
- [ ] getNode 可以通过 key 或 data 快速查找节点（O(1) 复杂度）
- [ ] append、remove 等操作正常工作
- [ ] 通过单元测试验证数据模型完整性

---

## Step 4: 实现工具函数（数据结构 - util.js）

### 📋 本步目标
实现通用工具函数，为数据模型和视图层提供支持。

### ✅ 要达到的效果
- 节点标记功能（markNodeData）
- 节点 key 获取（getNodeKey）
- 组件查找工具（findNearestComponent）

### 🎯 该做什么
1. **实现节点标记**：
   ```javascript
   export const NODE_KEY = '$treeNodeId';
   
   export const markNodeData = function(node, data) {
     if (!data || data[NODE_KEY]) return;
     Object.defineProperty(data, NODE_KEY, {
       value: node.id,
       enumerable: false,      // 不可枚举
       configurable: false,    // 不可配置
       writable: false         // 不可写
     });
   };
   ```

2. **实现 key 获取**：
   ```javascript
   export const getNodeKey = function(key, data) {
     if (!key) return data[NODE_KEY];
     return data[key];
   };
   ```

3. **实现组件查找**（用于拖拽）：
   ```javascript
   export const findNearestComponent = (element, componentName) => {
     let target = element;
     while (target && target.tagName !== 'BODY') {
       if (target.__vue__ && target.__vue__.$options.name === componentName) {
         return target.__vue__;
       }
       target = target.parentNode;
     }
     return null;
   };
   ```

4. **在 Node 构造函数中调用 markNodeData**：
   ```javascript
   // node.js
   import { markNodeData, NODE_KEY } from './util';
   
   constructor(options) {
     // ... 其他代码
     if (!Array.isArray(this.data)) {
       markNodeData(this, this.data);
     }
   }
   ```

### ❌ 不该做什么
- ❌ 不要添加不必要的工具函数
- ❌ 不要在工具函数中处理业务逻辑

### 🌿 分支命名
```bash
git checkout -b feature/tree-step4-utils
```

### ✔️ 验收标准
- [ ] markNodeData 正确为数据对象添加不可枚举的节点 ID
- [ ] getNodeKey 可以根据配置获取节点唯一标识
- [ ] findNearestComponent 可以查找最近的 Vue 组件实例
- [ ] 通过单元测试验证工具函数

---

## Step 5: 实现基础树渲染（架构 - 递归组件）

### 📋 本步目标
将数据模型与视图层连接，实现树的基础渲染，展示树形结构。

### ✅ 要达到的效果
- tree.vue 创建 TreeStore 实例并渲染根节点的子节点
- tree-node.vue 递归渲染节点，显示节点文本
- 树形结构正确显示，层级缩进清晰

### 🎯 该做什么
1. **完善 tree.vue**：
   ```vue
   <template>
     <div class="el-tree" role="tree">
       <el-tree-node
         v-for="child in root.childNodes"
         :node="child"
         :props="props"
         :key="getNodeKey(child)"
       ></el-tree-node>
       
       <div class="el-tree__empty-block" v-if="isEmpty">
         <span class="el-tree__empty-text">{{ emptyText }}</span>
       </div>
     </div>
   </template>
   
   <script>
   import TreeStore from './model/tree-store';
   import { getNodeKey } from './model/util';
   import ElTreeNode from './tree-node.vue';
   
   export default {
     name: 'ElTree',
     
     components: {
       ElTreeNode
     },
     
     props: {
       data: {
         type: Array
       },
       emptyText: {
         type: String,
         default: '暂无数据'
       },
       nodeKey: String,
       props: {
         default() {
           return {
             children: 'children',
             label: 'label',
             disabled: 'disabled'
           };
         }
       },
       defaultExpandAll: Boolean
     },
     
     data() {
       return {
         store: null,
         root: null
       };
     },
     
     computed: {
       isEmpty() {
         const { childNodes } = this.root;
         return !childNodes || childNodes.length === 0;
       }
     },
     
     methods: {
       getNodeKey(node) {
         return getNodeKey(this.nodeKey, node.data);
       }
     },
     
     created() {
       this.isTree = true;
       
       this.store = new TreeStore({
         key: this.nodeKey,
         data: this.data,
         props: this.props,
         defaultExpandAll: this.defaultExpandAll
       });
       
       this.root = this.store.root;
     }
   };
   </script>
   ```

2. **完善 tree-node.vue**（递归渲染）：
   ```vue
   <template>
     <div
       class="el-tree-node"
       v-show="node.visible"
       :class="{
         'is-expanded': expanded,
         'is-current': node.isCurrent,
         'is-hidden': !node.visible
       }"
       role="treeitem"
     >
       <div 
         class="el-tree-node__content"
         :style="{ 'padding-left': (node.level - 1) * 18 + 'px' }"
       >
         <!-- 展开图标 -->
         <span
           :class="[
             { 'is-leaf': node.isLeaf, expanded: !node.isLeaf && expanded },
             'el-tree-node__expand-icon',
             'el-icon-caret-right'
           ]"
         ></span>
         
         <!-- 节点文本 -->
         <span class="el-tree-node__label">{{ node.label }}</span>
       </div>
       
       <!-- 递归渲染子节点 -->
       <div
         class="el-tree-node__children"
         v-show="expanded"
         role="group"
       >
         <el-tree-node
           v-for="child in node.childNodes"
           :node="child"
           :key="getNodeKey(child)"
         ></el-tree-node>
       </div>
     </div>
   </template>
   
   <script>
   import { getNodeKey } from './model/util';
   
   export default {
     name: 'ElTreeNode',
     
     props: {
       node: {
         default() {
           return {};
         }
       }
     },
     
     data() {
       return {
         tree: null,
         expanded: false
       };
     },
     
     watch: {
       'node.expanded'(val) {
         this.$nextTick(() => this.expanded = val);
       }
     },
     
     methods: {
       getNodeKey(node) {
         return getNodeKey(this.tree.nodeKey, node.data);
       }
     },
     
     created() {
       const parent = this.$parent;
       
       // 向上查找 tree 根组件
       if (parent.isTree) {
         this.tree = parent;
       } else {
         this.tree = parent.tree;
       }
       
       // 同步展开状态
       if (this.node.expanded) {
         this.expanded = true;
       }
     }
   };
   </script>
   ```

3. **处理 defaultExpandAll**：
   ```javascript
   // node.js - constructor 中
   if (store.defaultExpandAll) {
     this.expanded = true;
   }
   ```

### ❌ 不该做什么
- ❌ 不要实现点击交互
- ❌ 不要实现展开/收起动画
- ❌ 不要实现复选框
- ❌ 不要处理拖拽

### 🌿 分支命名
```bash
git checkout -b feature/tree-step5-basic-render
```

### ✔️ 验收标准
- [ ] 树形结构正确渲染在页面上
- [ ] 节点层级缩进正确（每层 18px）
- [ ] 节点文本正确显示（支持自定义 label 字段）
- [ ] defaultExpandAll 配置生效
- [ ] 空数据时显示"暂无数据"提示
- [ ] 递归组件工作正常，支持任意层级

---

## Step 6: 实现展开收起功能（架构 - 交互逻辑）

### 📋 本步目标
实现节点的展开/收起交互，增加展开收起动画效果。

### ✅ 要达到的效果
- 点击展开图标可以展开/收起子节点
- 展开收起带有动画过渡效果
- 支持 expandOnClickNode 配置（点击节点内容也可以展开）
- 触发 node-expand 和 node-collapse 事件

### 🎯 该做什么
1. **添加展开图标点击事件**：
   ```vue
   <!-- tree-node.vue -->
   <span
     @click.stop="handleExpandIconClick"
     :class="[
       { 'is-leaf': node.isLeaf, expanded: !node.isLeaf && expanded },
       'el-tree-node__expand-icon',
       'el-icon-caret-right'
     ]"
   ></span>
   ```

2. **实现展开收起逻辑**：
   ```javascript
   // tree-node.vue
   methods: {
     handleExpandIconClick() {
       if (this.node.isLeaf) return;
       
       if (this.expanded) {
         this.tree.$emit('node-collapse', this.node.data, this.node, this);
         this.node.collapse();
       } else {
         this.node.expand();
         this.$emit('node-expand', this.node.data, this.node, this);
       }
     }
   }
   ```

3. **添加折叠动画组件**：
   ```vue
   <!-- tree-node.vue -->
   <el-collapse-transition>
     <div
       class="el-tree-node__children"
       v-show="expanded"
       role="group"
     >
       <el-tree-node
         v-for="child in node.childNodes"
         :node="child"
         :key="getNodeKey(child)"
       ></el-tree-node>
     </div>
   </el-collapse-transition>
   ```

4. **在 tree.vue 中监听并转发事件**：
   ```javascript
   // tree.vue
   props: {
     expandOnClickNode: {
       type: Boolean,
       default: true
     }
   },
   
   methods: {
     handleNodeExpand(nodeData, node, instance) {
       this.$emit('node-expand', nodeData, node, instance);
     }
   }
   ```

5. **添加节点内容点击**：
   ```vue
   <!-- tree-node.vue -->
   <div 
     class="el-tree-node__content"
     @click.stop="handleClick"
     :style="{ 'padding-left': (node.level - 1) * 18 + 'px' }"
   >
   ```

   ```javascript
   methods: {
     handleClick() {
       if (this.tree.expandOnClickNode) {
         this.handleExpandIconClick();
       }
     }
   }
   ```

### ❌ 不该做什么
- ❌ 不要实现手风琴模式（accordion）
- ❌ 不要实现延迟渲染（renderAfterExpand）
- ❌ 不要实现默认展开节点（defaultExpandedKeys）

### 🌿 分支命名
```bash
git checkout -b feature/tree-step6-expand-collapse
```

### ✔️ 验收标准
- [ ] 点击展开图标可以展开/收起节点
- [ ] 展开收起有动画效果
- [ ] expandOnClickNode 配置生效
- [ ] node-expand 和 node-collapse 事件正常触发
- [ ] 叶子节点不显示展开图标

---

## Step 7: 实现节点选中高亮（架构 - 状态管理）

### 📋 本步目标
实现节点的点击选中功能，当前选中的节点高亮显示。

### ✅ 要达到的效果
- 点击节点可以选中该节点
- 选中的节点背景高亮
- 支持 highlightCurrent 配置控制是否高亮
- 支持 currentNodeKey 配置默认选中节点
- 提供 setCurrentKey、getCurrentKey 等 API

### 🎯 该做什么
1. **添加 props 配置**：
   ```javascript
   // tree.vue
   props: {
     highlightCurrent: Boolean,
     currentNodeKey: [String, Number]
   },
   
   data() {
     return {
       store: null,
       root: null,
       currentNode: null
     };
   }
   ```

2. **在 TreeStore 中初始化当前节点**：
   ```javascript
   // tree-store.js - constructor
   this.currentNodeKey = options.currentNodeKey;
   
   // node.js - constructor
   if (key && store.currentNodeKey !== undefined && this.key === store.currentNodeKey) {
     store.currentNode = this;
     store.currentNode.isCurrent = true;
   }
   ```

3. **实现节点点击选中**：
   ```javascript
   // tree-node.vue
   methods: {
     handleClick() {
       const store = this.tree.store;
       store.setCurrentNode(this.node);
       this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
       this.tree.currentNode = this;
       
       if (this.tree.expandOnClickNode) {
         this.handleExpandIconClick();
       }
       
       this.tree.$emit('node-click', this.node.data, this.node, this);
     }
   }
   ```

4. **添加高亮样式类**：
   ```vue
   <!-- tree-node.vue -->
   <div
     class="el-tree-node"
     :class="{
       'is-expanded': expanded,
       'is-current': node.isCurrent,
       'is-hidden': !node.visible
     }"
   >
   ```

   ```vue
   <!-- tree.vue -->
   <div
     class="el-tree"
     :class="{
       'el-tree--highlight-current': highlightCurrent
     }"
   >
   ```

5. **提供外部 API**：
   ```javascript
   // tree.vue
   methods: {
     getCurrentNode() {
       const currentNode = this.store.getCurrentNode();
       return currentNode ? currentNode.data : null;
     },
     
     getCurrentKey() {
       if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getCurrentKey');
       const currentNode = this.getCurrentNode();
       return currentNode ? currentNode[this.nodeKey] : null;
     },
     
     setCurrentNode(node) {
       if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentNode');
       this.store.setUserCurrentNode(node);
     },
     
     setCurrentKey(key) {
       if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentKey');
       this.store.setCurrentNodeKey(key);
     },
     
     getNode(data) {
       return this.store.getNode(data);
     }
   }
   ```

6. **在 TreeStore 中实现辅助方法**：
   ```javascript
   // tree-store.js
   setUserCurrentNode(node) {
     const key = node[this.key];
     const currNode = this.nodesMap[key];
     this.setCurrentNode(currNode);
   }
   ```

### ❌ 不该做什么
- ❌ 不要实现多选功能
- ❌ 不要实现右键菜单
- ❌ 不要实现节点编辑

### 🌿 分支命名
```bash
git checkout -b feature/tree-step7-node-select
```

### ✔️ 验收标准
- [ ] 点击节点可以选中并高亮
- [ ] highlightCurrent 配置生效
- [ ] currentNodeKey 可以设置默认选中节点
- [ ] current-change 和 node-click 事件正常触发
- [ ] setCurrentKey、getCurrentKey 等 API 工作正常

---

## Step 8: 实现复选框功能（经验 - 级联选择算法）

### 📋 本步目标
实现节点复选框功能，包含父子级联选择逻辑。

### ✅ 要达到的效果
- 节点前显示复选框
- 勾选父节点，子节点全部勾选
- 勾选所有子节点，父节点自动勾选
- 部分子节点勾选，父节点显示半选状态
- 支持 checkStrictly 配置（父子不关联）
- 提供 getCheckedNodes、setCheckedKeys 等 API

### 🎯 该做什么
1. **添加复选框相关 props**：
   ```javascript
   // tree.vue
   props: {
     showCheckbox: {
       type: Boolean,
       default: false
     },
     checkStrictly: Boolean,
     defaultCheckedKeys: Array
   }
   ```

2. **在 tree-node.vue 中显示复选框**：
   ```vue
   <el-checkbox
     v-if="showCheckbox"
     v-model="node.checked"
     :indeterminate="node.indeterminate"
     :disabled="!!node.disabled"
     @click.native.stop
     @change="handleCheckChange"
   ></el-checkbox>
   ```

   ```javascript
   props: {
     showCheckbox: {
       type: Boolean,
       default: false
     }
   }
   ```

3. **实现 getChildState 工具函数**：
   ```javascript
   // node.js
   export const getChildState = node => {
     let all = true;
     let none = true;
     let allWithoutDisable = true;
     
     for (let i = 0, j = node.length; i < j; i++) {
       const n = node[i];
       if (n.checked !== true || n.indeterminate) {
         all = false;
         if (!n.disabled) {
           allWithoutDisable = false;
         }
       }
       if (n.checked !== false || n.indeterminate) {
         none = false;
       }
     }
     
     return { all, none, allWithoutDisable, half: !all && !none };
   };
   ```

4. **实现向上递归更新父节点状态**：
   ```javascript
   // node.js
   const reInitChecked = function(node) {
     if (node.childNodes.length === 0 || node.loading) return;
     
     const { all, none, half } = getChildState(node.childNodes);
     if (all) {
       node.checked = true;
       node.indeterminate = false;
     } else if (half) {
       node.checked = false;
       node.indeterminate = true;
     } else if (none) {
       node.checked = false;
       node.indeterminate = false;
     }
     
     const parent = node.parent;
     if (!parent || parent.level === 0) return;
     
     if (!node.store.checkStrictly) {
       reInitChecked(parent);
     }
   };
   ```

5. **实现 setChecked 方法**（向下级联）：
   ```javascript
   // node.js
   setChecked(value, deep, recursion, passValue) {
     this.indeterminate = value === 'half';
     this.checked = value === true;
     
     if (this.store.checkStrictly) return;
     
     // 向下级联
     if (deep) {
       const childNodes = this.childNodes;
       for (let i = 0, j = childNodes.length; i < j; i++) {
         const child = childNodes[i];
         passValue = passValue || value !== false;
         const isCheck = child.disabled ? child.checked : passValue;
         child.setChecked(isCheck, deep, true, passValue);
       }
       const { half, all } = getChildState(childNodes);
       if (!all) {
         this.checked = all;
         this.indeterminate = half;
       }
     }
     
     // 向上递归
     const parent = this.parent;
     if (!parent || parent.level === 0) return;
     
     if (!recursion) {
       reInitChecked(parent);
     }
   }
   ```

6. **处理复选框变化事件**：
   ```javascript
   // tree-node.vue
   methods: {
     handleCheckChange(value, ev) {
       this.node.setChecked(ev.target.checked, !this.tree.checkStrictly);
       this.$nextTick(() => {
         const store = this.tree.store;
         this.tree.$emit('check', this.node.data, {
           checkedNodes: store.getCheckedNodes(),
           checkedKeys: store.getCheckedKeys(),
           halfCheckedNodes: store.getHalfCheckedNodes(),
           halfCheckedKeys: store.getHalfCheckedKeys()
         });
       });
     },
     
     handleSelectChange(checked, indeterminate) {
       if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
         this.tree.$emit('check-change', this.node.data, checked, indeterminate);
       }
       this.oldChecked = checked;
       this.oldIndeterminate = indeterminate;
     }
   },
   
   watch: {
     'node.checked'(val) {
       this.handleSelectChange(val, this.node.indeterminate);
     },
     'node.indeterminate'(val) {
       this.handleSelectChange(this.node.checked, val);
     }
   },
   
   data() {
     return {
       oldChecked: null,
       oldIndeterminate: null
     };
   }
   ```

7. **在 TreeStore 中实现复选框相关方法**：
   ```javascript
   // tree-store.js
   getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
     const checkedNodes = [];
     const traverse = function(node) {
       const childNodes = node.root ? node.root.childNodes : node.childNodes;
       
       childNodes.forEach((child) => {
         if ((child.checked || (includeHalfChecked && child.indeterminate)) && 
             (!leafOnly || (leafOnly && child.isLeaf))) {
           checkedNodes.push(child.data);
         }
         traverse(child);
       });
     };
     
     traverse(this);
     return checkedNodes;
   }
   
   getCheckedKeys(leafOnly = false) {
     return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key]);
   }
   
   getHalfCheckedNodes() {
     const nodes = [];
     const traverse = function(node) {
       const childNodes = node.root ? node.root.childNodes : node.childNodes;
       
       childNodes.forEach((child) => {
         if (child.indeterminate) {
           nodes.push(child.data);
         }
         traverse(child);
       });
     };
     
     traverse(this);
     return nodes;
   }
   
   getHalfCheckedKeys() {
     return this.getHalfCheckedNodes().map((data) => (data || {})[this.key]);
   }
   
   setChecked(data, checked, deep) {
     const node = this.getNode(data);
     if (node) {
       node.setChecked(!!checked, deep);
     }
   }
   
   _initDefaultCheckedNodes() {
     const defaultCheckedKeys = this.defaultCheckedKeys || [];
     const nodesMap = this.nodesMap;
     
     defaultCheckedKeys.forEach((checkedKey) => {
       const node = nodesMap[checkedKey];
       if (node) {
         node.setChecked(true, !this.checkStrictly);
       }
     });
   }
   
   // 在 constructor 最后调用
   this._initDefaultCheckedNodes();
   ```

8. **在 tree.vue 中提供 API**：
   ```javascript
   // tree.vue
   methods: {
     getCheckedNodes(leafOnly, includeHalfChecked) {
       return this.store.getCheckedNodes(leafOnly, includeHalfChecked);
     },
     
     getCheckedKeys(leafOnly) {
       return this.store.getCheckedKeys(leafOnly);
     },
     
     setCheckedNodes(nodes, leafOnly) {
       if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');
       this.store.setCheckedNodes(nodes, leafOnly);
     },
     
     setCheckedKeys(keys, leafOnly) {
       if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedKeys');
       this.store.setCheckedKeys(keys, leafOnly);
     },
     
     setChecked(data, checked, deep) {
       this.store.setChecked(data, checked, deep);
     },
     
     getHalfCheckedNodes() {
       return this.store.getHalfCheckedNodes();
     },
     
     getHalfCheckedKeys() {
       return this.store.getHalfCheckedKeys();
     }
   }
   ```

### ❌ 不该做什么
- ❌ 不要实现 checkOnClickNode（点击节点勾选）
- ❌ 不要实现 checkDescendants（懒加载时级联）
- ❌ 不要实现禁用节点的复选框逻辑细节

### 🌿 分支命名
```bash
git checkout -b feature/tree-step8-checkbox
```

### ✔️ 验收标准
- [ ] 复选框正确显示
- [ ] 勾选父节点，子节点全部勾选
- [ ] 勾选所有子节点，父节点自动勾选
- [ ] 部分子节点勾选，父节点显示半选状态
- [ ] checkStrictly 配置生效（父子不关联）
- [ ] defaultCheckedKeys 配置生效
- [ ] getCheckedNodes、setCheckedKeys 等 API 工作正常
- [ ] check 和 check-change 事件正常触发

---

## Step 9: 实现节点增删改（架构 - CRUD 操作）

### 📋 本步目标
实现节点的增删改查操作，支持动态修改树结构。

### ✅ 要达到的效果
- 支持添加子节点（append）
- 支持在指定节点前后插入（insertBefore、insertAfter）
- 支持删除节点（remove）
- 支持更新节点子列表（updateKeyChildren）
- 数据变化时自动更新视图

### 🎯 该做什么
1. **在 Node 中实现 insertBefore 和 insertAfter**：
   ```javascript
   // node.js
   insertBefore(child, ref) {
     let index;
     if (ref) {
       index = this.childNodes.indexOf(ref);
     }
     this.insertChild(child, index);
   }
   
   insertAfter(child, ref) {
     let index;
     if (ref) {
       index = this.childNodes.indexOf(ref);
       if (index !== -1) index += 1;
     }
     this.insertChild(child, index);
   }
   ```

2. **完善 insertChild 方法**（同步原始数据）：
   ```javascript
   // node.js
   insertChild(child, index, batch) {
     if (!child) throw new Error('insertChild error: child is required.');
     
     if (!(child instanceof Node)) {
       // 同步到原始数据
       if (!batch) {
         const children = this.getChildren(true) || [];
         if (children.indexOf(child.data) === -1) {
           if (typeof index === 'undefined' || index < 0) {
             children.push(child.data);
           } else {
             children.splice(index, 0, child.data);
           }
         }
       }
       Object.assign(child, {
         parent: this,
         store: this.store
       });
       child = new Node(child);
     }
     
     child.level = this.level + 1;
     
     if (typeof index === 'undefined' || index < 0) {
       this.childNodes.push(child);
     } else {
       this.childNodes.splice(index, 0, child);
     }
     
     this.updateLeafState();
   }
   
   getChildren(forceInit = false) {
     if (this.level === 0) return this.data;
     const data = this.data;
     if (!data) return null;
     
     const props = this.store.props;
     let children = 'children';
     if (props) {
       children = props.children || 'children';
     }
     
     if (data[children] === undefined) {
       data[children] = null;
     }
     
     if (forceInit && !data[children]) {
       data[children] = [];
     }
     
     return data[children];
   }
   ```

3. **完善 removeChild 方法**（同步原始数据）：
   ```javascript
   // node.js
   removeChild(child) {
     const children = this.getChildren() || [];
     const dataIndex = children.indexOf(child.data);
     if (dataIndex > -1) {
       children.splice(dataIndex, 1);
     }
     
     const index = this.childNodes.indexOf(child);
     if (index > -1) {
       this.store && this.store.deregisterNode(child);
       child.parent = null;
       this.childNodes.splice(index, 1);
     }
     
     this.updateLeafState();
   }
   ```

4. **在 tree.vue 中提供 API**：
   ```javascript
   // tree.vue
   methods: {
     append(data, parentNode) {
       this.store.append(data, parentNode);
     },
     
     insertBefore(data, refNode) {
       this.store.insertBefore(data, refNode);
     },
     
     insertAfter(data, refNode) {
       this.store.insertAfter(data, refNode);
     },
     
     remove(data) {
       this.store.remove(data);
     },
     
     updateKeyChildren(key, data) {
       if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in updateKeyChild');
       this.store.updateChildren(key, data);
     }
   }
   ```

5. **在 TreeStore 中实现 updateChildren**：
   ```javascript
   // tree-store.js
   updateChildren(key, data) {
     const node = this.nodesMap[key];
     if (!node) return;
     const childNodes = node.childNodes;
     for (let i = childNodes.length - 1; i >= 0; i--) {
       const child = childNodes[i];
       this.remove(child.data);
     }
     for (let i = 0, j = data.length; i < j; i++) {
       const child = data[i];
       this.append(child, node.data);
     }
   }
   ```

6. **监听 data 变化**：
   ```javascript
   // tree.vue
   watch: {
     data(newVal) {
       this.store.setData(newVal);
     }
   }
   ```

7. **在 Node 中实现 updateChildren**：
   ```javascript
   // node.js
   updateChildren() {
     const newData = this.getChildren() || [];
     const oldData = this.childNodes.map((node) => node.data);
     
     const newDataMap = {};
     const newNodes = [];
     
     newData.forEach((item, index) => {
       const key = item[NODE_KEY];
       const isNodeExists = !!key && oldData.findIndex(data => data[NODE_KEY] === key) >= 0;
       if (isNodeExists) {
         newDataMap[key] = { index, data: item };
       } else {
         newNodes.push({ index, data: item });
       }
     });
     
     if (!this.store.lazy) {
       oldData.forEach((item) => {
         if (!newDataMap[item[NODE_KEY]]) this.removeChildByData(item);
       });
     }
     
     newNodes.forEach(({ index, data }) => {
       this.insertChild({ data }, index);
     });
     
     this.updateLeafState();
   }
   
   removeChildByData(data) {
     let targetNode = null;
     for (let i = 0; i < this.childNodes.length; i++) {
       if (this.childNodes[i].data === data) {
         targetNode = this.childNodes[i];
         break;
       }
     }
     if (targetNode) {
       this.removeChild(targetNode);
     }
   }
   ```

8. **在 tree-node.vue 中监听数据变化**：
   ```javascript
   // tree-node.vue - created
   const props = tree.props || {};
   const childrenKey = props['children'] || 'children';
   
   this.$watch(`node.data.${childrenKey}`, () => {
     this.node.updateChildren();
   });
   ```

### ❌ 不该做什么
- ❌ 不要实现批量操作的性能优化
- ❌ 不要实现操作历史记录（撤销/重做）
- ❌ 不要实现节点拖拽排序

### 🌿 分支命名
```bash
git checkout -b feature/tree-step9-crud
```

### ✔️ 验收标准
- [ ] append 可以添加子节点
- [ ] insertBefore 和 insertAfter 可以在指定位置插入节点
- [ ] remove 可以删除节点
- [ ] updateKeyChildren 可以更新节点的子列表
- [ ] data prop 变化时树自动更新
- [ ] 节点的原始数据和 Node 实例保持同步

---

## Step 10: 实现懒加载功能（经验 - 异步加载）

### 📋 本步目标
实现树节点的懒加载功能，支持异步加载子节点数据。

### ✅ 要达到的效果
- 开启 lazy 模式后，初始不渲染子节点
- 展开节点时调用 load 方法异步加载数据
- 加载过程中显示 loading 图标
- 加载完成后渲染子节点
- 叶子节点不触发加载

### 🎯 该做什么
1. **添加懒加载相关 props**：
   ```javascript
   // tree.vue
   props: {
     lazy: {
       type: Boolean,
       default: false
     },
     load: Function
   }
   ```

2. **在 TreeStore 中处理懒加载初始化**：
   ```javascript
   // tree-store.js - constructor
   if (this.lazy && this.load) {
     const loadFn = this.load;
     loadFn(this.root, (data) => {
       this.root.doCreateChildren(data);
       this._initDefaultCheckedNodes();
     });
   } else {
     this._initDefaultCheckedNodes();
   }
   ```

3. **在 Node 中实现懒加载逻辑**：
   ```javascript
   // node.js
   shouldLoadData() {
     return this.store.lazy === true && this.store.load && !this.loaded;
   }
   
   loadData(callback, defaultProps = {}) {
     if (this.store.lazy === true && this.store.load && !this.loaded && 
         (!this.loading || Object.keys(defaultProps).length)) {
       this.loading = true;
       
       const resolve = (children) => {
         this.childNodes = [];
         this.doCreateChildren(children, defaultProps);
         this.loaded = true;
         this.loading = false;
         this.updateLeafState();
         if (callback) {
           callback.call(this, children);
         }
       };
       
       this.store.load(this, resolve);
     } else {
       if (callback) {
         callback.call(this);
       }
     }
   }
   
   doCreateChildren(array, defaultProps = {}) {
     array.forEach((item) => {
       this.insertChild(Object.assign({ data: item }, defaultProps), undefined, true);
     });
   }
   ```

4. **修改 expand 方法支持懒加载**：
   ```javascript
   // node.js
   expand(callback, expandParent) {
     const done = () => {
       if (expandParent) {
         let parent = this.parent;
         while (parent.level > 0) {
           parent.expanded = true;
           parent = parent.parent;
         }
       }
       this.expanded = true;
       if (callback) callback();
     };
     
     if (this.shouldLoadData()) {
       this.loadData((data) => {
         if (data instanceof Array) {
           if (this.checked) {
             this.setChecked(true, true);
           } else if (!this.store.checkStrictly) {
             reInitChecked(this);
           }
           done();
         }
       });
     } else {
       done();
     }
   }
   ```

5. **在 tree-node.vue 中显示 loading 图标**：
   ```vue
   <span
     v-if="node.loading"
     class="el-tree-node__loading-icon el-icon-loading"
   ></span>
   ```

6. **处理懒加载时的叶子节点判断**：
   ```javascript
   // node.js - constructor
   const props = store.props;
   if (props && typeof props.isLeaf !== 'undefined') {
     const isLeaf = getPropertyFromData(this, 'isLeaf');
     if (typeof isLeaf === 'boolean') {
       this.isLeafByUser = isLeaf;
     }
   }
   
   // node.js
   updateLeafState() {
     if (this.store.lazy === true && this.loaded !== true && 
         typeof this.isLeafByUser !== 'undefined') {
       this.isLeaf = this.isLeafByUser;
       return;
     }
     const childNodes = this.childNodes;
     if (!this.store.lazy || (this.store.lazy === true && this.loaded === true)) {
       this.isLeaf = !childNodes || childNodes.length === 0;
       return;
     }
     this.isLeaf = false;
   }
   
   const getPropertyFromData = function(node, prop) {
     const props = node.store.props;
     const data = node.data || {};
     const config = props[prop];
     
     if (typeof config === 'function') {
       return config(data, node);
     } else if (typeof config === 'string') {
       return data[config];
     } else if (typeof config === 'undefined') {
       const dataProp = data[prop];
       return dataProp === undefined ? '' : dataProp;
     }
   };
   ```

7. **处理懒加载时的默认展开**：
   ```javascript
   // node.js - constructor
   if (this.level > 0 && store.lazy && store.defaultExpandAll) {
     this.expand();
   }
   ```

### ❌ 不该做什么
- ❌ 不要实现加载失败重试机制
- ❌ 不要实现加载缓存策略
- ❌ 不要实现预加载功能

### 🌿 分支命名
```bash
git checkout -b feature/tree-step10-lazy-load
```

### ✔️ 验收标准
- [ ] 懒加载模式下，初始不加载子节点
- [ ] 展开节点时调用 load 方法
- [ ] 加载过程中显示 loading 图标
- [ ] 加载完成后子节点正确渲染
- [ ] isLeaf 配置可以标记叶子节点
- [ ] 懒加载时复选框级联逻辑正确

---

## Step 11: 实现拖拽功能（经验 - 原生拖拽 API）

### 📋 本步目标
实现节点的拖拽排序功能，使用 HTML5 Drag and Drop API。

### ✅ 要达到的效果
- 节点可以拖动
- 拖动时显示放置指示器（before/after/inner）
- 放置到目标位置时更新树结构
- 支持 allowDrag 和 allowDrop 配置限制拖拽
- 触发拖拽相关事件

### 🎯 该做什么
1. **添加拖拽相关 props**：
   ```javascript
   // tree.vue
   props: {
     draggable: {
       type: Boolean,
       default: false
     },
     allowDrag: Function,
     allowDrop: Function
   },
   
   data() {
     return {
       dragState: {
         showDropIndicator: false,
         draggingNode: null,
         dropNode: null,
         allowDrop: true,
         dropType: null
       }
     };
   }
   ```

2. **在模板中添加拖拽样式类和指示器**：
   ```vue
   <!-- tree.vue -->
   <div
     class="el-tree"
     :class="{
       'el-tree--highlight-current': highlightCurrent,
       'is-dragging': !!dragState.draggingNode,
       'is-drop-not-allow': !dragState.allowDrop,
       'is-drop-inner': dragState.dropType === 'inner'
     }"
     role="tree"
   >
     <!-- ... -->
     <div
       v-show="dragState.showDropIndicator"
       class="el-tree__drop-indicator"
       ref="dropIndicator"
     ></div>
   </div>
   ```

3. **在 tree-node.vue 中添加拖拽事件**：
   ```vue
   <div
     class="el-tree-node"
     :draggable="tree.draggable"
     @dragstart.stop="handleDragStart"
     @dragover.stop="handleDragOver"
     @dragend.stop="handleDragEnd"
     @drop.stop="handleDrop"
   >
   ```

4. **实现拖拽事件处理方法**：
   ```javascript
   // tree-node.vue
   methods: {
     handleDragStart(event) {
       if (!this.tree.draggable) return;
       this.tree.$emit('tree-node-drag-start', event, this);
     },
     
     handleDragOver(event) {
       if (!this.tree.draggable) return;
       this.tree.$emit('tree-node-drag-over', event, this);
       event.preventDefault();
     },
     
     handleDrop(event) {
       event.preventDefault();
     },
     
     handleDragEnd(event) {
       if (!this.tree.draggable) return;
       this.tree.$emit('tree-node-drag-end', event, this);
     }
   }
   ```

5. **在 tree.vue created 中监听拖拽事件**：
   ```javascript
   // tree.vue - created
   let dragState = this.dragState;
   
   // dragstart - 开始拖动
   this.$on('tree-node-drag-start', (event, treeNode) => {
     if (typeof this.allowDrag === 'function' && !this.allowDrag(treeNode.node)) {
       event.preventDefault();
       return false;
     }
     event.dataTransfer.effectAllowed = 'move';
     
     try {
       event.dataTransfer.setData('text/plain', '');
     } catch (e) {}
     
     dragState.draggingNode = treeNode;
     this.$emit('node-drag-start', treeNode.node, event);
   });
   
   // dragover - 拖动经过
   this.$on('tree-node-drag-over', (event, treeNode) => {
     const dropNode = findNearestComponent(event.target, 'ElTreeNode');
     const oldDropNode = dragState.dropNode;
     if (oldDropNode && oldDropNode !== dropNode) {
       removeClass(oldDropNode.$el, 'is-drop-inner');
     }
     
     const draggingNode = dragState.draggingNode;
     if (!draggingNode || !dropNode) return;
     
     let dropPrev = true;
     let dropInner = true;
     let dropNext = true;
     let userAllowDropInner = true;
     
     if (typeof this.allowDrop === 'function') {
       dropPrev = this.allowDrop(draggingNode.node, dropNode.node, 'prev');
       userAllowDropInner = dropInner = this.allowDrop(draggingNode.node, dropNode.node, 'inner');
       dropNext = this.allowDrop(draggingNode.node, dropNode.node, 'next');
     }
     
     event.dataTransfer.dropEffect = dropInner ? 'move' : 'none';
     
     if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
       if (oldDropNode) {
         this.$emit('node-drag-leave', draggingNode.node, oldDropNode.node, event);
       }
       this.$emit('node-drag-enter', draggingNode.node, dropNode.node, event);
     }
     
     if (dropPrev || dropInner || dropNext) {
       dragState.dropNode = dropNode;
     }
     
     // 防止非法拖拽
     if (dropNode.node.nextSibling === draggingNode.node) {
       dropNext = false;
     }
     if (dropNode.node.previousSibling === draggingNode.node) {
       dropPrev = false;
     }
     if (dropNode.node.contains(draggingNode.node, false)) {
       dropInner = false;
     }
     if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
       dropPrev = false;
       dropInner = false;
       dropNext = false;
     }
     
     // 计算放置位置
     const targetPosition = dropNode.$el.getBoundingClientRect();
     const treePosition = this.$el.getBoundingClientRect();
     
     let dropType;
     const prevPercent = dropPrev ? (dropInner ? 0.25 : (dropNext ? 0.45 : 1)) : -1;
     const nextPercent = dropNext ? (dropInner ? 0.75 : (dropPrev ? 0.55 : 0)) : 1;
     
     let indicatorTop = -9999;
     const distance = event.clientY - targetPosition.top;
     
     if (distance < targetPosition.height * prevPercent) {
       dropType = 'before';
     } else if (distance > targetPosition.height * nextPercent) {
       dropType = 'after';
     } else if (dropInner) {
       dropType = 'inner';
     } else {
       dropType = 'none';
     }
     
     // 更新指示器位置
     const iconPosition = dropNode.$el.querySelector('.el-tree-node__expand-icon').getBoundingClientRect();
     const dropIndicator = this.$refs.dropIndicator;
     
     if (dropType === 'before') {
       indicatorTop = iconPosition.top - treePosition.top;
     } else if (dropType === 'after') {
       indicatorTop = iconPosition.bottom - treePosition.top;
     }
     
     dropIndicator.style.top = indicatorTop + 'px';
     dropIndicator.style.left = (iconPosition.right - treePosition.left) + 'px';
     
     if (dropType === 'inner') {
       addClass(dropNode.$el, 'is-drop-inner');
     } else {
       removeClass(dropNode.$el, 'is-drop-inner');
     }
     
     dragState.showDropIndicator = dropType === 'before' || dropType === 'after';
     dragState.allowDrop = dragState.showDropIndicator || userAllowDropInner;
     dragState.dropType = dropType;
     this.$emit('node-drag-over', draggingNode.node, dropNode.node, event);
   });
   
   // dragend - 拖动结束
   this.$on('tree-node-drag-end', (event) => {
     const { draggingNode, dropType, dropNode } = dragState;
     event.preventDefault();
     event.dataTransfer.dropEffect = 'move';
     
     if (draggingNode && dropNode) {
       const draggingNodeCopy = { data: draggingNode.node.data };
       if (dropType !== 'none') {
         draggingNode.node.remove();
       }
       if (dropType === 'before') {
         dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
       } else if (dropType === 'after') {
         dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
       } else if (dropType === 'inner') {
         dropNode.node.insertChild(draggingNodeCopy);
       }
       if (dropType !== 'none') {
         this.store.registerNode(draggingNodeCopy);
       }
       
       removeClass(dropNode.$el, 'is-drop-inner');
       
       this.$emit('node-drag-end', draggingNode.node, dropNode.node, dropType, event);
       if (dropType !== 'none') {
         this.$emit('node-drop', draggingNode.node, dropNode.node, dropType, event);
       }
     }
     if (draggingNode && !dropNode) {
       this.$emit('node-drag-end', draggingNode.node, null, dropType, event);
     }
     
     dragState.showDropIndicator = false;
     dragState.draggingNode = null;
     dragState.dropNode = null;
     dragState.allowDrop = true;
   });
   ```

6. **在 Node 中实现 contains 和 sibling 方法**：
   ```javascript
   // node.js
   get nextSibling() {
     const parent = this.parent;
     if (parent) {
       const index = parent.childNodes.indexOf(this);
       if (index > -1) {
         return parent.childNodes[index + 1];
       }
     }
     return null;
   }
   
   get previousSibling() {
     const parent = this.parent;
     if (parent) {
       const index = parent.childNodes.indexOf(this);
       if (index > -1) {
         return index > 0 ? parent.childNodes[index - 1] : null;
       }
     }
     return null;
   }
   
   contains(target, deep = true) {
     const walk = function(parent) {
       const children = parent.childNodes || [];
       let result = false;
       for (let i = 0, j = children.length; i < j; i++) {
         const child = children[i];
         if (child === target || (deep && walk(child))) {
           result = true;
           break;
         }
       }
       return result;
     };
     
     return walk(this);
   }
   ```

7. **引入必要的依赖**：
   ```javascript
   // tree.vue
   import { findNearestComponent } from './model/util';
   import { addClass, removeClass } from 'element-ui/src/utils/dom';
   ```

### ❌ 不该做什么
- ❌ 不要实现跨树拖拽
- ❌ 不要实现拖拽动画效果
- ❌ 不要实现拖拽撤销功能

### 🌿 分支命名
```bash
git checkout -b feature/tree-step11-drag-drop
```

### ✔️ 验收标准
- [ ] 节点可以拖动
- [ ] 拖动时显示放置指示器
- [ ] 可以放置到节点前/后/内部
- [ ] 拖拽完成后树结构正确更新
- [ ] allowDrag 和 allowDrop 配置生效
- [ ] 防止非法拖拽（拖到自己或子节点）
- [ ] 拖拽相关事件正常触发

---

## Step 12: 实现高级功能（架构 - 完善细节）

### 📋 本步目标
实现树组件的其他高级功能，包括过滤、键盘导航、自定义渲染等。

### ✅ 要达到的效果
- 支持节点过滤功能
- 支持键盘导航（上下左右、回车空格）
- 支持自定义节点内容渲染
- 支持手风琴模式
- 支持延迟渲染优化
- 支持无障碍访问

### 🎯 该做什么
1. **实现节点过滤功能**：
   ```javascript
   // tree.vue
   props: {
     filterNodeMethod: Function
   },
   
   methods: {
     filter(value) {
       if (!this.filterNodeMethod) throw new Error('[Tree] filterNodeMethod is required when filter');
       this.store.filter(value);
     }
   }
   
   // tree-store.js
   filter(value) {
     const filterNodeMethod = this.filterNodeMethod;
     const traverse = function(node) {
       const childNodes = node.root ? node.root.childNodes : node.childNodes;
       
       childNodes.forEach((child) => {
         child.visible = filterNodeMethod.call(child, value, child.data, child);
         traverse(child);
       });
       
       if (!node.visible && childNodes.length) {
         let allHidden = true;
         allHidden = !childNodes.some(child => child.visible);
         
         if (node.root) {
           node.root.visible = allHidden === false;
         } else {
           node.visible = allHidden === false;
         }
       }
       if (!value) return;
       
       if (node.visible && !node.isLeaf && !this.lazy) node.expand();
     };
     
     traverse(this);
   }
   ```

2. **实现键盘导航**：
   ```javascript
   // tree.vue
   data() {
     return {
       treeItems: null,
       checkboxItems: []
     };
   },
   
   computed: {
     treeItemArray() {
       return Array.prototype.slice.call(this.treeItems);
     }
   },
   
   methods: {
     initTabIndex() {
       this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
       this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
       const checkedItem = this.$el.querySelectorAll('.is-checked[role=treeitem]');
       if (checkedItem.length) {
         checkedItem[0].setAttribute('tabindex', 0);
         return;
       }
       this.treeItems[0] && this.treeItems[0].setAttribute('tabindex', 0);
     },
     
     handleKeydown(ev) {
       const currentItem = ev.target;
       if (currentItem.className.indexOf('el-tree-node') === -1) return;
       const keyCode = ev.keyCode;
       this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
       const currentIndex = this.treeItemArray.indexOf(currentItem);
       let nextIndex;
       
       if ([38, 40].indexOf(keyCode) > -1) { // up、down
         ev.preventDefault();
         if (keyCode === 38) { // up
           nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
         } else {
           nextIndex = (currentIndex < this.treeItemArray.length - 1) ? currentIndex + 1 : 0;
         }
         this.treeItemArray[nextIndex].focus();
       }
       
       if ([37, 39].indexOf(keyCode) > -1) { // left、right
         ev.preventDefault();
         currentItem.click();
       }
       
       const hasInput = currentItem.querySelector('[type="checkbox"]');
       if ([13, 32].indexOf(keyCode) > -1 && hasInput) { // space enter
         ev.preventDefault();
         hasInput.click();
       }
     }
   },
   
   mounted() {
     this.initTabIndex();
     this.$el.addEventListener('keydown', this.handleKeydown);
   },
   
   updated() {
     this.treeItems = this.$el.querySelectorAll('[role=treeitem]');
     this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
   },
   
   watch: {
     checkboxItems(val) {
       Array.prototype.forEach.call(val, (checkbox) => {
         checkbox.setAttribute('tabindex', -1);
       });
     }
   }
   ```

3. **在 tree-node.vue 中添加无障碍属性**：
   ```vue
   <div
     class="el-tree-node"
     :class="{
       'is-focusable': !node.disabled
     }"
     role="treeitem"
     tabindex="-1"
     :aria-expanded="expanded"
     :aria-disabled="node.disabled"
     :aria-checked="node.checked"
   >
   ```

4. **实现自定义节点内容**：
   ```javascript
   // tree.vue
   props: {
     renderContent: Function
   }
   
   // tree-node.vue
   props: {
     renderContent: Function
   },
   
   components: {
     NodeContent: {
       props: {
         node: {
           required: true
         }
       },
       render(h) {
         const parent = this.$parent;
         const tree = parent.tree;
         const node = this.node;
         const { data, store } = node;
         return (
           parent.renderContent
             ? parent.renderContent.call(parent._renderProxy, h, { _self: tree.$vnode.context, node, data, store })
             : tree.$scopedSlots.default
               ? tree.$scopedSlots.default({ node, data })
               : <span class="el-tree-node__label">{ node.label }</span>
         );
       }
     }
   }
   
   // 在模板中使用
   <node-content :node="node"></node-content>
   ```

5. **实现手风琴模式**：
   ```javascript
   // tree.vue
   props: {
     accordion: Boolean
   }
   
   // tree-node.vue - created
   if (this.tree.accordion) {
     this.$on('tree-node-expand', node => {
       if (this.node !== node) {
         this.node.collapse();
       }
     });
   }
   
   // tree-node.vue - handleChildNodeExpand
   handleChildNodeExpand(nodeData, node, instance) {
     this.broadcast('ElTreeNode', 'tree-node-expand', node);
     this.tree.$emit('node-expand', nodeData, node, instance);
   }
   
   // 需要 emitter mixin
   import emitter from 'element-ui/src/mixins/emitter';
   
   export default {
     mixins: [emitter]
   }
   ```

6. **实现延迟渲染**：
   ```javascript
   // tree.vue
   props: {
     renderAfterExpand: {
       type: Boolean,
       default: true
     }
   }
   
   // tree-node.vue
   props: {
     renderAfterExpand: {
       type: Boolean,
       default: true
     }
   },
   
   data() {
     return {
       childNodeRendered: false
     };
   },
   
   watch: {
     'node.expanded'(val) {
       this.$nextTick(() => this.expanded = val);
       if (val) {
         this.childNodeRendered = true;
       }
     }
   },
   
   created() {
     if (this.node.expanded) {
       this.expanded = true;
       this.childNodeRendered = true;
     }
   }
   
   // 模板
   <div
     class="el-tree-node__children"
     v-if="!renderAfterExpand || childNodeRendered"
     v-show="expanded"
   >
   ```

7. **实现其他配置项**：
   ```javascript
   // tree.vue
   props: {
     indent: {
       type: Number,
       default: 18
     },
     iconClass: String,
     checkOnClickNode: Boolean,
     autoExpandParent: {
       type: Boolean,
       default: true
     },
     defaultExpandedKeys: Array
   },
   
   watch: {
     defaultExpandedKeys(newVal) {
       this.store.defaultExpandedKeys = newVal;
       this.store.setDefaultExpandedKeys(newVal);
     }
   }
   
   // tree-store.js
   setDefaultExpandedKeys(keys) {
     keys = keys || [];
     this.defaultExpandedKeys = keys;
     
     keys.forEach((key) => {
       const node = this.getNode(key);
       if (node) node.expand(null, this.autoExpandParent);
     });
   }
   
   // node.js - constructor
   const defaultExpandedKeys = store.defaultExpandedKeys;
   const key = store.key;
   if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
     this.expand(null, store.autoExpandParent);
   }
   ```

8. **实现 checkOnClickNode**：
   ```javascript
   // tree-node.vue - handleClick
   if (this.tree.checkOnClickNode && !this.node.disabled) {
     this.handleCheckChange(null, {
       target: { checked: !this.node.checked }
     });
   }
   ```

9. **实现右键菜单事件**：
   ```javascript
   // tree-node.vue
   <div
     @contextmenu="($event) => this.handleContextMenu($event)"
   >
   
   methods: {
     handleContextMenu(event) {
       if (this.tree._events['node-contextmenu'] && 
           this.tree._events['node-contextmenu'].length > 0) {
         event.stopPropagation();
         event.preventDefault();
       }
       this.tree.$emit('node-contextmenu', event, this.node.data, this.node, this);
     }
   }
   ```

10. **实现 getNodePath 方法**：
    ```javascript
    // tree.vue
    methods: {
      getNodePath(data) {
        if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getNodePath');
        const node = this.store.getNode(data);
        if (!node) return [];
        const path = [node.data];
        let parent = node.parent;
        while (parent && parent !== this.root) {
          path.push(parent.data);
          parent = parent.parent;
        }
        return path.reverse();
      }
    }
    ```

### ❌ 不该做什么
- ❌ 不要实现虚拟滚动
- ❌ 不要实现节点搜索高亮
- ❌ 不要实现国际化

### 🌿 分支命名
```bash
git checkout -b feature/tree-step12-advanced
```

### ✔️ 验收标准
- [ ] filter 方法可以过滤节点
- [ ] 键盘导航工作正常（上下左右、回车空格）
- [ ] renderContent 和 scoped slot 自定义渲染生效
- [ ] accordion 手风琴模式生效
- [ ] renderAfterExpand 延迟渲染生效
- [ ] defaultExpandedKeys 默认展开生效
- [ ] checkOnClickNode 配置生效
- [ ] node-contextmenu 事件触发
- [ ] ARIA 属性正确设置，支持无障碍访问

---

## Step 13: 完善样式和文档（架构 - 收尾工作）

### 📋 本步目标
完善组件样式，编写组件文档和示例，完成最终测试。

### ✅ 要达到的效果
- 组件样式与 ElementUI 保持一致
- 提供完整的 API 文档
- 提供丰富的使用示例
- 通过完整的测试用例

### 🎯 该做什么
1. **编写或复制样式文件**：
   - 复制 `packages/theme-chalk/src/tree.scss`
   - 确保所有状态的样式都已定义

2. **编写 API 文档**：
   ```markdown
   ## Tree Attributes
   | 参数 | 说明 | 类型 | 可选值 | 默认值 |
   |-----|-----|------|-------|--------|
   | data | 展示数据 | array | — | — |
   | empty-text | 内容为空的时候展示的文本 | String | — | — |
   | node-key | 每个树节点用来作为唯一标识的属性 | String | — | — |
   | props | 配置选项 | object | — | — |
   | ... | ... | ... | ... | ... |
   
   ## Tree Methods
   ## Tree Events
   ## Tree Scoped Slot
   ```

3. **编写使用示例**：
   - 基础用法
   - 可选择
   - 懒加载
   - 自定义节点内容
   - 节点过滤
   - 手风琴模式
   - 可拖拽节点

4. **编写单元测试**：
   - 基础渲染测试
   - 展开收起测试
   - 复选框测试
   - 拖拽测试
   - API 方法测试

5. **性能测试**：
   - 大数据量渲染（1000+ 节点）
   - 懒加载性能
   - 拖拽流畅度

6. **兼容性测试**：
   - Chrome、Firefox、Safari、Edge
   - 移动端浏览器

7. **代码检查**：
   - ESLint 检查通过
   - 代码格式统一
   - 移除 console 和调试代码
   - 添加必要的注释

### ❌ 不该做什么
- ❌ 不要修改核心逻辑
- ❌ 不要添加新功能
- ❌ 不要过度优化

### 🌿 分支命名
```bash
git checkout -b feature/tree-step13-polish
```

### ✔️ 验收标准
- [ ] 样式完整且美观
- [ ] API 文档详细准确
- [ ] 示例代码可运行
- [ ] 单元测试覆盖率 > 80%
- [ ] 性能测试通过
- [ ] 所有浏览器兼容
- [ ] 代码质量检查通过
- [ ] 功能与 ElementUI Tree 100% 一致

---

## 总结

通过以上 13 个步骤，你将完整地复刻出 ElementUI 的 Tree 组件。整个复刻过程严格遵循：

### 🏗️ 架构维度
- **Step 1-5**：搭建组件架构（目录结构、组件分层、递归渲染）
- **Step 6-7**：实现交互逻辑（展开收起、节点选中）
- **Step 12**：完善高级功能（过滤、键盘导航、自定义渲染）

### 🗂️ 数据结构维度
- **Step 2-3**：构建数据模型（Node 类、TreeStore 类）
- **Step 4**：实现工具函数（节点标记、key 获取）
- **Step 9**：实现节点增删改（CRUD 操作）

### 💡 经验维度
- **Step 8**：实现复选框级联算法
- **Step 10**：实现懒加载机制
- **Step 11**：实现原生拖拽 API

### 🎯 最佳实践
1. **每一步都可独立运行和测试**
2. **循序渐进，避免一次性实现所有功能**
3. **先实现核心，再完善细节**
4. **重视数据模型设计，视图只是数据的映射**
5. **充分测试每一步的功能完整性**

通过这个复刻过程，你不仅能得到一个功能完整的 Tree 组件，更重要的是深刻理解组件设计的思想和实现细节。
